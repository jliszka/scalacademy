
 == LEVEL 4 ==

Welcome back! Okay, first order of business. You've probably been getting a little frustrated
typing things in at the "scala>" prompt. Especially when the code you're typing in stretches
to the end of the line. Fortunately, there's an easy solution!

On your Mac, open up TextEdit: type Command-space, then type textedit, then hit enter.

In the Format menu, select Make Plain Text (alternatively, hit Command-Shift-T).

Once you've done that, type ok to continue.
---
===
Alright, You're now ready to write some code!

Type this into TextEdit, on separate lines:

val metersPerMile = 1609
def milesToMeters(miles: Int) = miles + metersPerMile
milesToMeters(15)

Then save the file by hitting Command-s. Give the file a name like script.scala and save it to 
the scalacademy folder (to get there you will have to click on the little "down" triangle next 
to the text box labeled "Save As"). Make sure the checkbox labeled "If no extension is 
provided, use .txt" is UNCHECKED.

When you're done with all that, come back here and type ok to continue.
---
===
Now, type :load script.scala.

If Scala says "That file does not exist", go back and make sure you followed these instructions
exactly. I promise it works!

Once you've got the script loaded, type ok and hit enter.
---
declared[Int]("metersPerMile")
hasTypeStr("milesToMeters", "(miles: Int)Int")
===
Great! It worked!

You can see that when you load the file, it's just as if you had typed it in at the scala>
prompt directly. Check it by typing milesToMeters(21) now.
---
hasType[Int]
===
Alright!

Wait, there's a bug! Do you see it?

Yep, it should be miles * metersPerMiles, not miles + metersPerMile. Silly.

Fix the bug by editing your code in TextEdit, and save the file by hitting Command-s.
Then, reload the file by typing :load script.scala again.

Once the file is reloaded, type milesToMeters(21) to make sure the bug is fixed.
---
hasValue[Int](33789)
===
Great!! Not so bad, huh?

You might be wondering what happened to the old definition of milesToMeters. You've essentially
defined it twice, right? Well, the answer is that you can't get to it. The new definition is
hiding the old definition, and from now on, when you type milesToMeters, you only get the new
definition.

Okay, so what do you think will happen if you redefine metersPerMile? Well, try it!

Type val metersPerMile = 10. (an obvious lie)
---
declared[Int]("metersPerMile", 10)
===
Alright, nothing surprising so far. But what do you think milesToMeters(1) will be? Any guesses?

Well, try it!
---
hasValue[Int](1609)
===
Ah ha! Was that what you guessed?

Okay, I owe you an explanation. The old definition of metersPerMile is still there, but it's being
hidden by the new definition. All *future* references to metersPerMile will use the new definition.
But references to metersPerMile you've already made (in particular in milesToMeters), still get
to use the old definition!

I'm going to explain this two more times in two differen tways, because it's important and a
little tricky.

Way #1:
When you define a function, names of vals (or other functions) will always refer to the values
they had at the time you defined the function.

Way #2:
After you define a function, nothing you can do (short of redefining the function itself)
will alter the behavior of the function as it existed at the time you defined it.

This might seem like a weird restriction, but it's actually a really useful rule. It's like
guard rails on the side of a highway next to a cliff. It's just a good idea.

Okay, enough talk. Let's do something new.

Type val kmPerMile = 1.609.
---
declared[Double]("kmPerMile", 1.609)
===
Ooh, a new type! Shiny! It has a weird name though, Double. It's short for something like
"double-precision floating point number" but that's not important. What's important is that,
whereas Ints represent whole numbers, Doubles can represent fractional values too.

Let's do a little math, but paying close attention to the types.

Try 3 * 5.5.
---
hasValue[Double](16.5)
===
Okay, nothing super crazy. The result was a fractional number, so the result type is Double.

Now try 4 * 5.5.
---
hasValue[Double](22.0)
===
Okay, interesting! Even though the result was a whole number, the result type is still a Double.

The general rule here is that if any single value in a numeric expression is a Double, the result
will be a Double.

Test it out by typing 3 + 4 + 1.0 + 7.
---
hasValue[Double](15.0)
===
Cool, okay! Now try 15 / 2.0.
---
hasValue[Double](7.5)
===
Makes sense, right? Okay, now try 15 / 2. But before you hit enter, try to guess what the result
will be. Remember, the result will be a Double ONLY if there is some Double value in the expression.
---
hasValue[Int](7)
===
A little tricky, huh? The result has to be an Int since only Ints were involved in the expression.
So Scala truncated 7.5 (the "true" result) by removing everything after the decimal point, and 
called it an Int. Simple as that.

Got the hang of it? Play around with Doubles and Ints a bit if you want, and make sure the
result is what you expect. It's a good idea to try to guess the result type before you hit enter!

Type ok when you're ready to move on.
---
===
Okay! Now suppose you have some vals declared as Ints. Type this:

val milesPerGallon = 25
val milesToGo = 80
---
declared[Int]("milesPerGallon", 25)
declared[Int]("milesToGo", 80)
===
Good. Now you want to find out how many gallons you need to go 80 miles. You would do this
by dividing milesToGo by milesPerGallon, right? But they are both Ints, and you need a
result that's a Double.

So what do you do? See if you can figure it out using things you already know.

Remember, all you need is a single Double in the expression to make the result a Double.

When you get the result you want, type ok.
---
hasValue[Double](3.2)
===
Awesome! Nice work!

Did you do something like 1.0 * milesToGo / milesPerGallon? If not, think about why that works.
It's actually a pretty common trick that programmers use all the time.

But anyway, beware of division with Ints! Or rather, be aware of division with Ints.
---
===
Okay! Now using the kmPerMile val you declared earlier, write a function called milesToKm that
takes an Int argument called miles and returns the number of kilometers it represents.
---
hasTypeStr("milesToKm", "(miles:Int)Double")
eval[Double]("mikesToKm(1)", 1.609)
eval[Double]("mikesToKm(10)", 16.09)
===
Nice work!

Alright, now let's do one more revision to our car example.

Write a function called willIMakeIt that takes four arguments: tankCapacity, percentFull, milesPerGallon,
and milesToGo. The percentFull argument should be a Double, expected to be between 0.0 and 1.0 representing
the fraction of gas remaining in the tank. For example, 0.5 would mean half full. The function should
return true if you are going to make it to the next gas station, and false otherwise.

Write your code in TextEdit and use :load like before. Remember, you can edit, save and :load as many times
as you want while you're working on your code.
---
hasTypeStr("willIMakeIt", "(tankCapacity: Int,percentFull: Double,milesPerGallon: Int,milesToGo: Int)Boolean")
eval[Boolean]("willIMakeIt(12, 0.25, 25, 70)", true)
eval[Boolean]("willIMakeIt(12, 0.25, 25, 80)", false)
eval[Boolean]("willIMakeIt(16, 0.25, 25, 80)", true)
eval[Boolean]("willIMakeIt(15, 0.20, 25, 80)", false)
eval[Boolean]("willIMakeIt(15, 0.20, 30, 80)", true)
===
Nice, you did it!
---
===
